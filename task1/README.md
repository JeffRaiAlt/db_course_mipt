##### Домашнее задание 1. Создание и нормализация базы данных

##### 

**1НФ** (атрибуты простые, на пересечении строк и столбцов скаляры)

В таблицах customer и transaction поля уже выглядит как атомарные (повторяющихся массивов/списков нет, атрибуты простые).
Замечание: что здесь можно сделать, привести типы  list\_price, standard\_cost к типу DECIMAL, DOB и transaction\_date к типу DATE, owns\_car к типу  BOOLEAN



**2НФ** (1НФ + каждый столбец который не является ключом, зависит от первичного ключа)

Таблица customer, берём customer\_id как первичный ключ, он простой (один столбец).
Никаких составных ключей нет. Атрибуты зависят только от  customer\_id.

Таблица transaction, берём transaction\_id как первичный ключ, он простой (один столбец).
Никаких составных ключей нет. Атрибуты зависят только от  transaction\_id.
Значит 1НФ выполнена, 2НФ тоже.



**3НФ** (2НФ + нет транзитивных зависимостей, неключевой атрибут не должен зависеть от неключевого ).
Таблицы исходно не в 3НФ, основные нарушения:

Таблица customer: транзитивная зависимость по почтовому индексу.
В реальности postcode  → state, country (внутри одной страны индекс должен однозначно задавать штат/регион). Тогда в customers получается транзитивность
customer\_id → postcode → state, country. Это нарушает 3НФ.
Потенциально транзитивная зависимость job\_title → job\_industry\_category, но в нашем случае это не так, много полей где нет  job\_title, но есть  job\_industry\_category.
Вынос  postcode → state, country в справочники из-за наличия функциональной зависимости относится к 3НФ.


Дополнительно сделал справочники для  job\_industry\_category и wealth\_segments это больше оптимизация.



Таблица transaction: избыточные продуктовые атрибуты.
В transactions поля brand, product\_line, product\_class, product\_size, standard\_cost на первый взгляд функционально зависят от product\_id (а не от ключа transaction\_id)
(такая зависимость неключевого атрибута (brand, …) от неключевого (product\_id) -  нарушение 3НФ), но это не так, зависимость есть, но другая. Имеем, product\_id не уникален
и поэтому не может использоваться в качестве ключа (это всего лишь слабый текстовый/сквозной идентификатор, а не ключ).  Например, нередко у разных продуктов  product\_id=0
или даже не нулевой, но продукты разные. А вот уникальной нужно считать связку всех параметров продукта, за исключение может цены, но и она у одинаковых продуктов одинакова.
Поэтому для исправления функциональной зависимости, нужно вынести продукты в отдельную таблицу, где в качестве идентификатора использовать суррогатный ключ.
Чтобы не потерять исходную информацию о значениях которые может принимать product\_id, я его оставил в таблице transaction. Стоит заметить, что в некоторых случаях,
когда  product\_id=0 ссылки на сам продукт нет, поэтому в таблице transactions ссылки на соответствующий продукт через суррогатный ключ не будет.



Дополнительно для всех повторяющихся значений сделал справочники.

